# Part ii C++基础 --类
>如何写一个类..？
## 0 类与函数
我们使用类定义自己的数据类型，通过定义新的类型反映待解决问题中的各种概念。  
类的基本思想是**数据抽象**和**封装**。数据抽象是一种依赖于**接口**和**实现**分离的编程技术。
>类的接口包括用户所能执行的操作，类的实现包括其数据成员、具体实现接口的函数体、以及各种私有函数。  
>封装使接口和实现分离。用户只能使用接口而无法访问实现部分。
### 0.1 成员函数
$~~~~~$成员函数必须在类内声明，但可以选择定义在类内或类外。如果在类外定义，需要使用“ :: “指明。  
`class tori{`  
`public:`  
$~~~~$`void summon();`  
`}`  

`void tori::summon (  ) { };`  
$~~~~~$这样，可以像C一样，将定义写在.h头文件中，实现写在.c文件中。  

#### this指针的默认传入

$~~~~~$对于普通的成员函数，编译器会默认传入一个this指针，指向调用该函数的对象。你可以隐式或显式地使用它。  
$~~~~~$例如，类有一个名为mood的数据成员，在类函数内使用mood等同于this->mood。  
$~~~~~$this是一个常量指针，他总是指向这个对象。  
$~~~~~$你可以return *this 来返回调用该函数的对象。

#### 引入const成员函数
$~~~~~$可以通过在函数参数列表后加上const关键字，来让该函数无法修改成员的值。  
$~~~~~$这里，const修改了隐式this指针的类型。**默认this的类型：**  
*           Classname* const this  
**对于const成员函数的this：**  
*           const Classname* const this  
$~~~~~$你需要知道的是，const在修饰指针时，当它位于类型前，表示指向常量的指针；位于类型后，表示一个不可修改的常量指针。


## 1 类的特殊函数

### 1.1 构造函数   
类通过一个或几个构造函数来控制其对象初始化的过程，该函数的名字与类名相同。如果你没有为你的类定义构造函数，编译器会为你隐式定义一个**合成的默认构造函数**。他能做什么？
>合成的默认构造函数，能调用其成员对象或基类子对象的构造函数，对于位于静态区域或命名空间作用域的对象澪初始化，其他内置类型包括指针，是未定义的。

当你定义构造函数后，编译器便不再为你合成默认版本。你可以使用 = default 来要求编译器为你做。

---

#### 构造函数初始值列表

位于参数列表和函数体之间。推荐使用构造函数初始值列表进行数据成员的赋值。

`Classname(int a, string s): number(a), name(s) {  }`

初始值列表按照成员在类中声明的顺序进行初始化，避免了额外的拷贝或赋值。！对于**常量成员**，**引用成员**，**没有构造函数的成员对象**，**必须使用初始化列表**。

----

#### 委托构造函数

将一个构造函数的工作或部分工作委托给另一个构造函数。

`Classname(string name, int num1, int num2): name(name), number1(num1), number2(num2) {  }`

`classname(string name): classnmae(name, 0, 0) {  }`

`classname(): classname("", 0, 0) {  }`

---

#### 构造函数----隐式的类类型转换

**单参数的构造函数**会被当成一种类型转换函数。例如有一个tori类的构造函数接受string类型。当我们需要一个Tori对象(例如函数传参的时候)，提供的却是string类型，这时会通过该构造函数生成一个临时的tori对象。

`getmood(Tori a) { ...  }`

`getmood("happy"); `

该例中，发生了string到Tori的类型转换。a内string成员值为"happy"。其他成员根据你的构造函数定义情况而定。  
然而，编译器**只会执行一步类型转换**，若是隐式使用两种转换规则，会报错。

---

#### explict -- 抑制构造函数定义的隐式转换

explict关键字可以阻止构造函数发生类型转换。该关键字只在类内声明构造函数使用，在类外定义时不应该重复。  
发生隐式转换的一种情况是执行拷贝形式的初始化时（使用=），这时只能直接初始化，而不能使用explict构造函数。

`Tori a(kanbe) //its ture`

`Tori a = kanbe //its wrong if u use explict`

>尽管编译器不会将explict的构造函数用于隐式转换，但你仍可以显示的使用他强制转换。

### 1.2 拷贝、赋值和析构

拷贝、赋值和析构函数用于类的拷贝、赋值和销毁。该部分与动态内存相关，你现在需要直到，某些类不能依赖于合成的版本。







## 2 访问控制 与 封装




## 3 类的其他特性




## 4 类的作用域
