# Part ii C++基础 --类
>如何写一个类..？
## 0 类与函数
我们使用类定义自己的数据类型，通过定义新的类型反映待解决问题中的各种概念。  
类的基本思想是**数据抽象**和**封装**。数据抽象是一种依赖于**接口**和**实现**分离的编程技术。
>类的接口包括用户所能执行的操作，类的实现包括其数据成员、具体实现接口的函数体、以及各种私有函数。  
>封装使接口和实现分离。用户只能使用接口而无法访问实现部分。
### 0.1 成员函数
$~~~~~$成员函数必须在类内声明，但可以选择定义在类内或类外。如果在类外定义，需要使用“ :: “指明。  
`class tori{`  
`public:`  
$~~~~$`void summon();`  
`}`  

`void tori::summon (  ) { };`  
$~~~~~$这样，可以像C一样，将定义写在.h头文件中，实现写在.c文件中。  

#### this指针的默认传入

$~~~~~$对于普通的成员函数，编译器会默认传入一个this指针，指向调用该函数的对象。你可以隐式或显式地使用它。  
$~~~~~$例如，类有一个名为mood的数据成员，在类函数内使用mood等同于this->mood。  
$~~~~~$this是一个常量指针，他总是指向这个对象。  
$~~~~~$你可以return *this 来返回调用该函数的对象。

#### 引入const成员函数
$~~~~~$可以通过在函数参数列表后加上const关键字，来让该函数无法修改成员的值。  
$~~~~~$这里，const修改了隐式this指针的类型。**默认this的类型：**  
*           Classname* const this  
**对于const成员函数的this：**  
*           const Classname* const this  
$~~~~~$你需要知道的是，const在修饰指针时，当它位于类型前，表示指向常量的指针；位于类型后，表示一个不可修改的常量指针。


## 1 类的特殊函数

### 1.1 构造函数   
类通过一个或几个构造函数来控制其对象初始化的过程，该函数的名字与类名相同。如果你没有为你的类定义构造函数，编译器会为你隐式定义一个**合成的默认构造函数**。他能做什么？
>合成的默认构造函数，能调用其成员对象或基类子对象的构造函数，对于位于静态区域或命名空间作用域的对象澪初始化，其他内置类型包括指针，是未定义的。

当你定义构造函数后，编译器便不再为你合成默认版本。你可以使用 = default 来要求编译器为你做。

---

#### 构造函数初始值列表

位于参数列表和函数体之间。推荐使用构造函数初始值列表进行数据成员的赋值。

`Classname(int a, string s): number(a), name(s) {  }`

初始值列表按照成员在类中声明的顺序进行初始化，避免了额外的拷贝或赋值。！对于**常量成员**，**引用成员**，**没有构造函数的成员对象**，**必须使用初始化列表**。

----

#### 委托构造函数

将一个构造函数的工作或部分工作委托给另一个构造函数。

`Classname(string name, int num1, int num2): name(name), number1(num1), number2(num2) {  }`

`classname(string name): classnmae(name, 0, 0) {  }`

`classname(): classname("", 0, 0) {  }`

---

#### 构造函数----隐式的类类型转换

**单参数的构造函数**会被当成一种类型转换函数。例如有一个tori类的构造函数接受string类型。当我们需要一个Tori对象(例如函数传参的时候)，提供的却是string类型，这时会通过该构造函数生成一个临时的tori对象。

`void setmood(Tori a) { ...  }`

`setmood("happy"); `

该例中，发生了string到Tori的类型转换。a内string成员值为"happy"。其他成员根据你的构造函数定义情况而定。  
然而，编译器**只会执行一步类型转换**，若是隐式使用两种转换规则，会报错。

---

#### explict -- 抑制构造函数定义的隐式转换

explict关键字可以阻止构造函数发生类型转换。该关键字只在类内声明构造函数使用，在类外定义时不应该重复。  
发生隐式转换的一种情况是执行拷贝形式的初始化时（使用=），这时只能直接初始化，而不能使用explict构造函数。

`Tori a(kanbe) //its ture`

`Tori a = kanbe //its wrong if u use explict`

>尽管编译器不会将explict的构造函数用于隐式转换，但你仍可以显示的使用他强制转换。

### 1.2 拷贝、赋值和析构

拷贝、赋值和析构函数用于类的拷贝、赋值和销毁。该部分与动态内存相关，你现在需要知道，某些类不能依赖于合成的版本。
这一部分内容将在oop设计的笔记内详细说明。



## 2 访问控制 与 封装

### 2.1 访问说明符

我们使用**访问说明符**来加强类的封装性。c++中的访问说明符有**public**，**protected**，**private**。

`class Tori {`  
`public: `  
$~~~~$`//成员1`  
$~~~~$`//成员2`  
$~~~~$`//成员3`  
`private: `  
$~~~~$`//成员4`  
$~~~~$`//成员5`  
`}`

*       private的成员可以被类的成员函数访问，但不能被使用该类的代码访问。private部分封装了（隐藏了）的实现细节。  
*       public的成员在整个程序内可访问。通常在这里定义类的接口。

---

#### class 与 struct

class与struct都可以开始类的定义。唯一区别在于，用class定义的类成员默认都是private，用struct定义的类成员默认public。

---

### 2.2 友元

类可以允许其他类或某些函数访问他的非公有成员，方法是使用**友元(friend)**。

`class Class1 { `   
`//友元声明`  
`friend Class1 add(const Class1&, const Class1&);`  
`friend Class1 sub(const Class1&, const Class1&);`  
`//成员`  
`private:`  
`...`  
`}`  
`//独立函数`  
`Class1 add(const Class1&, const Class1&);`  
`Class1 add(const Class1&, const Class1&);`

假如在Class1内声明了friend Class2; 那么Class2可以访问Class1内的private域。

注意友元的声明仅仅指定了访问权限，并非函数声明。友元不是类的成员，也不受其所在区域访问控制级别的约束。一般来说，最好在类开始或结束前集中声明友元。

---


## 3 类的其他特性

### 3.1 自定义成员类型

类可以自定义某种类型在类中的别名，方法是使用**typedef**或**using**。该名字与其他成员一样受访问权限限制。这也是隐藏实现细节方式的一种。

`typedef int pos;`  
`using pos = int;`

### 3.2 令成员作为内联函数

规模较小的函数适合被声明为内联的，通常在类外函数定义处使用 **inline** 关键字修饰。

---

### 3.3 重载成员函数

同名函数在参数的数量或类型上可以有所区别，这是被重载了。编译器根据实参及其数量来决定运行哪个版本的函数。还有，如果你学习过 java 这样典型的面向对象语言，你应该知道不应该用返回值的不同来区分同名函数。

重载后的函数已经是不同的函数。因此如果想要使用友元，需要对不同版本分别声明。

---

### 3.4 确保数据成员可被改变

有些时候，我们会想在const成员函数内能修改某个数据成员的值。可以在该数据成员的声明前加 **mutable** 关键字。

`mutable int num;`

---

### 3.5 基于const的重载

可以根据成员函数是否const来进行重载。

`const string& operator[](int i) const { return name[i]; } //只读版本`  
`string& operator[](int i) { return name[i] } //可修改版本`

这时编译器会根据对象是否const来决定调用哪个版本。这通常用于容器类或字符串类中。

---











