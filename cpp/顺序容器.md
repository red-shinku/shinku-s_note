# part ii c++标准库 --顺序容器

>容器就是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力，该位置与元素加入容器时的位置相对应。（关联容器根据关键字的值来存储元素）

## 1 顺序容器概述

顺序容器的类型：

+ **vertor** ，可变大小数组。支持快速随机访问。但在尾部之外插入或删除元素可能很慢。

+ **deque** ，双端队列。支持快速随机访问。在头尾插入/删除很快。
+ **list** ，双向链表。只支持双向顺序访问。任意位置插入/删除很快。
+ **forward_list** ，单向链表。只支持单向顺序访问。任意位置插入/删除很快。
+ **array** ，固定大小数组。支持快速随机访问。不能添加/删除元素。
+ **string** ，与vector相似的容器，专门用于字符。随机访问快，尾插/删快。

## 2 容器库概览

容器类型上的操作形成了一种层次：  
！某些操作是所有容器类型都提供的。  
！某些操作仅针对顺序容器、关联容器或者无序容器。  
！某些操作只适用于一小部分容器。

顺序容器几乎可以保存任意类型的元素。

`vector<Classname> myvec; //尖括号内指定元素类型`

需要注意的是，大多数STL容器**要求元素至少是可拷贝构造或可移动构造的**。我们可以为不支持特定操作需求的类型定义容器，但这样的话就只能使用那些没有特殊要求的容器操作了。  
例如，顺序容器一个版本的构造函数接受容器大小参数，他需要使用元素类型的默认构造函数（需要先分配空间，再构造对象）。但某些类没有默认构造函数的话，我们在构造这种容器时就不能只传递给他一个元素数目参数。

`vector<ClassNoDefault> v1(10, init); //正确，提供了元素初始化器`  
`vector<ClassNoDefault> v2(10); //错误`

### 2.1 基础容器操作

---

#### 容器类中的类型别名

+ **iterator** $~~~~~~~~~~~~~~~~~~~~~$此容器类型的迭代器类型

+ **const_iterator** $~~~~~~~~~~$只读迭代器类型
+ **size_type** $~~~~~~~~~~~~~~~~~$无符号整数类型，足以保存此种容器最大可能的大小
+ **difference_type**$~~~~~~~~$带符号整数类型，足够保存两个迭代器之间的距离
+ **value_type** $~~~~~~~~~~~~~~~$容器中元素的类型
+ **reference** $~~~~~~~~~~~~~~~~~$元素的左值类型，与value_type含义相同
+ **const_reference** $~~~~~$ 元素的const左值类型。

>对于difference_type和容器C，有两个迭代器it1和it2，我们可以用`C::difference_type distance = it1 - it2;`得到迭代器距离。在c++11标准后，可以使用**auto**自动推断值类型。

>左值即能获取其具体地址的表达式，可以出现在等号左边或右边。右值通常是临时对象（函数返回的非引用类型），即将销毁的对象，或字面量（15，114），表达式结果（a + b），std::move(x)的返回值等，无法获取其地址，只能出现在等号右边。

---

#### 构造函数

+ **Container ctn;**$~~~~~~~~~~~~~~~~~~~~~~~~$默认构造函数，构造空容器。

+ **Container ctn1(ctn2);** $~~~~~~~~~~~~$构造ctn2的拷贝ctn1。
+ **Container ctn(bgin, ed);** $~~~~~~~~$将迭代器bgin和ed指定范围的元素拷贝到ctn（array不支持）
+ **Container ctn{a, b, c...};** $~~~~~~~~$列表初始化ctn。

---

#### 赋值与交换swap

+ **ctn1 = ctn2;** $~~~~~~~~~~~~~~~~~~~~$将ctn1中的元素替换为ctn2中的元素。

+ **ctn = {a, b, c...};** $~~~~~~~~~~~~~$将ctn中的元素替换为列表中元素。
+ **ctn1.swap(ctn2);** $~~~~~~~~~~~~$交换ctn1和ctn2的元素。
+ **swap(ctn1, ctn2);**$~~~~~~~~~~~~$相当于`ctn1.swap(ctn2);`

---

#### 大小

+ **ctn.size()** $~~~~~~~~~~~~~~~~~~~~~~~~$ctn中元素的数目(forward_list不支持)

+ **ctn.max_size()** $~~~~~~~~~~~~~~~~$ctn可存的最大元素数目。
+ **ctn.empty()** $~~~~~~~~~~~~~~~~~~~~$若ctn为空，返回true，否则false。

---

#### 添加/删除元素(array不适用)

+ **ctn.insert(args)** $~~~~~~~~~~~~~$ 将args中的元素拷贝进ctn。

+ **ctn.emplace(inits)** $~~~~~~~~~$ 使用inits构造ctn中的一个元素
+ **ctn.erase(args)** $~~~~~~~~~~~~~$ 删除args指定的元素。
+ **ctn.clear()** $~~~~~~~~~~~~~~~~~~~~~$ 删除ctn所有元素，返回void。

>insert方法需要先创建一个对象，再拷贝/移动进容器，而emplace方法是将传入的inits直接作为构造函数的参数，在内存中原地构造一个元素。这省去的中间对象与拷贝操作，更高效，支持复杂构造。

---

#### 关系运算符

+ **== !=** $~~~~~~~~~~~~~~~~$ 所有容器都支持，比较大小，元素逐个相等与否。

+ **< <= > >=** $~~~~~~~~~$ 规则类似字符串比较，不支持无序关联容器。

---

#### 获取迭代器

+ **ctn.begin()，ctn.end()** $~~~~~~~~$ 返回指向**首元素**或指向**尾元素之后位置**的迭代器。

+ **ctn.cbegin()，ctn.cend()** $~~~~$ 返回const_iterator。

---

#### 反向容器的而外成员(不支持forward_list)

+ **reverse_iterator** $~~~~~~~~~~~~~~~~~~~~~~~~$逆序寻址元素的迭代器。

+ **const_reverse_iterator** $~~~~~~~~~~~~~$只读逆序迭代器。
+ **ctn.rbegin()，ctn.rend()** $~~~~~~~~~~~~$不用说了吧。
+ **ctn.crbegin()，ctn.crend()** $~~~~~~~~$ 1！5！

---

### 2.2 小谈迭代器

>更多迭代器的内容在泛型算法内。






# bottom
