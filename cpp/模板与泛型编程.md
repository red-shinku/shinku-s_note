# partiii 面向对象设计 - 模板与泛型编程

>oop编程和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：oop能处理在程序运行之前都未知的情况；而泛型编程中，在编译时就能获知类型了。

## 1 定义模板

模板是c++泛型编程的基础。一个模板就是一个创建类或函数的蓝图。通过模板，我们可以让任意类型被我们的类或函数接受。可以想想容器类。

### 1.1 函数模板

定义一个函数模板，而不是为每个类型都定义一个新函数。模板定义以关键字**template**开始，后跟一个**模板参数列表**，以逗号分隔多个**模板参数**。

```
template <typename T, class U>
void makefriend(T p1, U p2){
     
}

```

在模板参数列表里，模板类型 typename 和 class 并无二至。编译器根据我们传入的实参，来将确切类型绑定到 T 和 U 上。

+ #### 非类型模板参数

对于类型模板参数，如`template <typename T>`，T 是一个类型。  
但对于非类型模板参数，如`template <int N>`，N是一个值。该值必须在编译期就决定，也就是常量表达式。

```
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]){
    return strcmp(p1, p2);
}

compare("hi", "ciao");
```
看看上面这个例子。"hi"的类型是`const char[3]`（加上字符结束符），我们传入了一个字符数组引用(char[N]整个数组)，同时保留了其长度信息；而不是传入`const char*`，丢失了长度信息。strcmp 将字符比较结果返回(需要处理字典序)。

>c++17后引入了通用常量 `template <auto V>`。c++20后，非类型模板参数支持：指针或引用，字符串字面量，枚举值，结构化类型。

+ #### 模板编译

只有当我们实例化出模板的一个特定版本时，编译器才会生成代码，这影响了我们如何组织代码。  
通常我们将类定义和函数声明放在头文件中，将函数定义放在源文件中。但是对于函数模板和类模板，为了生成一个实例化的版本，编译器还需要掌握具体的定义。**因此函数模板和类模板成员函数的定义通常放在头文件中。**

>！！！保证传递给模板的实参支持模板所要求的操作，是调用者的责任。

### 1.2 类模板

类模板的定义如下：

```
template <typename T> class Blob {
public:
    typedef T value_t;
    typedef typename std::vector<T>::size_type size_type;
}
```


# bottom



