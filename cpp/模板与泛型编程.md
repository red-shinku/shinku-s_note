# partiii 面向对象设计 - 模板与泛型编程

>oop编程和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：oop能处理在程序运行之前都未知的情况；而泛型编程中，在编译时就能获知类型了。

## 1 定义模板

模板是c++泛型编程的基础。一个模板就是一个创建类或函数的蓝图。通过模板，我们可以让任意类型被我们的类或函数接受。可以想想容器类。

### 1.1 函数模板

定义一个函数模板，而不是为每个类型都定义一个新函数。模板定义以关键字**template**开始，后跟一个**模板参数列表**，以逗号分隔多个**模板参数**。

```cpp
template <typename T, class U>
void makefriend(T p1, U p2){
     
}
```
在模板参数列表里，模板类型 typename 和 class 并无二至。编译器根据我们传入的实参，来将确切类型绑定到 T 和 U 上。

+ #### 非类型模板参数

对于类型模板参数，如`template <typename T>`，T 是一个类型。  
但对于非类型模板参数，如`template <int N>`，N是一个值。该值必须在编译期就决定，也就是常量表达式。

```cpp
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]){
    return strcmp(p1, p2);
}

compare("hi", "ciao");
```
看看上面这个例子。"hi"的类型是`const char[3]`（加上字符结束符），我们传入了一个字符数组引用(char[N]整个数组)，同时保留了其长度信息；而不是传入`const char*`，丢失了长度信息。strcmp 将字符比较结果返回(需要处理字典序)。

>c++17后引入了通用常量 `template <auto V>`。c++20后，非类型模板参数支持：指针或引用，字符串字面量，枚举值，结构化类型。

+ #### 模板编译

只有当我们实例化出模板的一个特定版本时，编译器才会生成代码，这影响了我们如何组织代码。  
通常我们将类定义和函数声明放在头文件中，将函数定义放在源文件中。但是对于函数模板和类模板，为了生成一个实例化的版本，编译器还需要掌握具体的定义。**因此函数模板和类模板成员函数的定义通常放在头文件中。**

>！！！保证传递给模板的实参支持模板所要求的操作，是调用者的责任。

### 1.2 类模板

类模板的定义如下：

```cpp
template <typename T> class Blob {
public:
    typedef T value_t;
    typedef typename std::vector<T>::size_type size_type;
    Blob<T>::Blob(.....) { ... }
}
```

>模版类的构造函数要以模版参数开始。`Blob<T>::`指定了构造函数的作用域。但对于其他在类作用域的成员，我们可以直接使用名字`Blob`。 


#### 类模版和友元

如果一个类模版包含一个非模版友元，则友元被授权可以访问所有模版实例。  
如果友元是模版，类可以授权给所有友元模版实例，也可以只授权给特定实例。

#### 模版类型别名

我们可以用typedef来命名实例化的类模版：`typedef Blob<string> strBlob;`  
但是不能用typedef来命名模版，因为他不是一个类型：`Blob<T>`

在c++11后，可以使用**using**来定义模版别名：
```
template <模版参数列表>
using 别名 = 类型表达式;
```

```cpp
template <typename T>
using Myclass1 = Classname<T, T>;

template <typename T>
using Myclass2 = Classname<T, unsigned>;

Myclass1<int> a; //a的类型为Classname<int, int>
Myclass2<int> b; //b的类型为Classname<int, unsigned>
```
#### 类模版的static成员

普通的类中，static成员有且只有一个实例。但对于类模版，类模版的每个不同类型都会有自己独立的static成员。  
static成员若在类外定义，需要使用`template <typename T>`开头，并且用`Classname<T>::`限定成员。

>从c++17开始，static成员可以在类内直接初始化，前提是他被声明为inline。在这之前，静态成员必须在类外定义。

### 1.3 模版参数

#### 模版参数与作用域

模版参数遵循普通的作用域规则。模版参数会隐藏外层作用域中声明相同的名字。但是，在模版内不能重用模版参数名。

```cpp
typedef int A;

template <typename A, typename B>
void f(A a, B b){
    A tmp = a; //这里tmp的类型为A，而不是int
    int B; //报错，重声明了模版参数B
}
```
#### 使用模版类的类型成员

在普通类中定义的类型成员，我们可以通过作用域运算符这样访问他：`Classname::my_type`。  
但默认情况下，c++假定通过作用域运算符访问的名字不是类型。普通类之所以可以这样做，是因为编译器有他的定义，编译器知道my_type是一个类型。  
但对于模版类，假定T是一个模版类型，那么下面的代码：
`T::size_type* ptr;`，编译器会以为这是两个值做乘法。我们必须使用 **typename** 显式说明 size_type 是一个类型。  
`typename T::size_type* ptr;`

#### 默认模版实参

就像我们能为函数参数提供默认实参，我们也可以提供默认模版实参。

```cpp
template <class T = int>
class Numbers{
public:
    Numbers(T v = 0): val(v) { }
private:
    T val;
}

Numbers<> dfnum; //尖括号留空使用默认类型
```

### 1.4 成员模版（本身是模版的类成员）

一个类可以包含本身是模版的成员函数，这种成员叫**成员模版**。成员模版不能是虚函数。

需要注意的是类模版里的成员模版，如果要在类外定义，必须同时提供类和成员的模版参数列表，并且类模版的参数列表应该在前面。

```cpp
template <typename T>
struct AAA{
    template <typename U>
    void f(U smthin);
}

template <typename T>
template <typename U>
void f(U smthin){
    return;
}
```

### 1.5 控制模版的实例化

我们知道，模版被使用时才会进行实例化。这导致，相同的实例可能会出现在多个对象文件中。当两个以上独立编译的源文件使用了相同的模版，并提供了相同的模版参数，每个文件中就都会有该模版的一个实例。  
在大型项目中，这可能会导致巨大的额外开销。

>模版的本质不是代码，而是代码生成规则。我们把模版的声明+定义写在头文件里，默认情况下，使用者会根据这个规则在它们的源文件里生成模版实例（即具体代码）。

我们可以通过显式实例化来避免这种开销。可以有如下形式：

```markdown
extern template _declaration_ ; //显式实例化声明

template _declaration_ ; //显式实例化定义
```
_declaration_ 是一个类或函数声明，其中的模版参数以被换成模版实参。  
两种形式具有不同含义，并且通常配合使用。extern 版本禁止在当前文件生成该模版实例。template 版本告诉编译器在当前文件强制生成唯一的一份实例。  
具体例子：

```cpp
//foo.h
template <typename T>
void f(T);

extern template void f(int); //禁止在包含foo.h的文件生成f(int)


//foo.cpp
#include "foo.h"

template void f(int); //唯一实例，链接时统一使用
```



# bottom



