# Part iii 类设计者的工具 --拷贝控制

>如何规定类的行为..？

本章节主要描述，类如何控制自己的实例在拷贝、赋值、移动或销毁时做什么。类通过一些特殊的成员函数来控制这些操作——拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。  
我们称这些操作为**拷贝控制操作**。

## 1 拷贝、赋值与销毁

>在定义任何类时，拷贝控制操作都是必要部分。如果我们不显式定义他们，编译器会为我们定义，但该版本的行为可能并非对象或我们的预期。

### 1.1 拷贝构造函数

如果一个构造函数的第一个参数是其自身类类型的引用，且任何额外参数都有默认值，那这个就是拷贝构造函数。

>你可以想几个问题：为什么拷贝构造函数的第一个参数必须是引用类型？在c++基础部分笔记里，类的章节那部分还提到了，单参数构造函数可能会被用于隐式类型转换，那么拷贝构造函数呢？稍后进行解释。

```cpp
class Foo {
public:
    Foo();
    Foo(const Foo&); //拷贝构造函数
};
```

#### 合成拷贝构造函数

与普通构造一样，如果我们声明了拷贝构造函数，编译器就不会合成默认的版本（这时如果你没定义就会出现链接错误）。  
一般情况，合成的版本，会将其参数的成员逐个拷贝到正在创建的对象中，对于类类型的成员，则调用其拷贝构造函数。  
但是！**对于某些类，合成拷贝构造函数会阻止拷贝该类的对象**。比如在含有不可拷贝成员的类中，合成的版本会自动声明为 **deleted** 即不可用。

```cpp
struct A{
    A(const A&) = delete; //该类的对象不可拷贝；
}；
struct B{
    A a;
};

B b1;
B b2(b1); //失败！B中含有不可拷贝成员
```

#### 拷贝初始化 与 直接初始化

在上面的代码中，使用了b1来直接初始化b2。直接初始化是要求编译器使用普通的函数匹配，选择与我们提供的函数最匹配的构造函数（选择重载函数的哪个版本）。

```cpp
string dots(10, '.'); //直接初始化，调用了string的构造函数
string str(dots);  //直接初始化，调用了string的拷贝构造函数
```

拷贝初始化通常使用 拷贝构造函数 或 移动构造函数，并且中间可能会有隐式的类型转换发生。下列情况会发生拷贝初始化：

+ Classname cls1 = cls2;

+ 将一个对象作为实参传递给一个非引用类型的形参。
+ 从一个返回类型为 非引用类型 的函数，返回一个对象。
+ 用花括号初始化数组元素，或一个聚合类中的成员。

**为什么拷贝构造函数自己的参数必须是引用类型？** 要知道，拷贝构造函数被用来初始化非引用类类型参数。如果其形参不是引用类型，我们调用拷贝构造时，需要拷贝它的实参，但要拷贝实参，又需要调用拷贝构造——死循环了。

#### 拷贝初始化的限制

现在来回答本小小节开头时提到的第二个问题。我们有时候会使用 **explicit** 关键字阻止构造函数隐式使用。对于使用explicit声明的构造函数或拷贝构造，它只能用于直接初始化。或者显式调用它:

```cpp
vector<int> v1(10); 
vector<int> v2 = 10; //错误，vector接受大小的构造函数是explicit的

vector<int> v3 = vector<int>(10); //可以显式调用
```

### 1.2 拷贝赋值运算符

#### 重载赋值运算符

首先你要知道，**重载运算符**实际上是一个函数，也有返回类型与参数列表，**其名字**由 **operator关键字** 后接要定义的运算符的符号组成。因此赋值运算符就是一个名为 `operator=` 的函数。  
如果一个运算符是一个成员函数，那么在它的定义内，其左侧对象被绑定要隐式的this指针上。

>某些运算符必须定义为成员函数。

```cpp
struct Book {
    std::string bkname;
    int ISBN;
    int nums;

    Book& operator=(const Book& bk){
        bkname = bk.bkname;
        ISBN = bk.ISBN;
        nums = bk.nums;
        return *this;
    }
}
```

类似拷贝构造，**合成拷贝赋值运算符**会阻止某些类的拷贝。如果不是这样，它会将其右侧对象的非静态成员 赋予 左侧对象的对应成员。

### 1.3 析构函数

析构函数由波浪号接类名组成。析构函数不接受参数，也不能被重载。

```cpp
struct Myclass{
    ~Myclass();
}
```

#### 析构函数做什么工作的？

在构造函数中，成员的初始化是在函数体之前，按照其在类中出现的顺序初始化。  
而对于析构函数，先执行函数体，后按成员出现的逆序销毁。



## 2 拷贝控制 和 资源管理  



## 3 交换操作



## 4 
