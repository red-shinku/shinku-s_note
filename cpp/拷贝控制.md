# Part iii 类设计者的工具 --拷贝控制

>如何规定类的行为..？

本章节主要描述，类如何控制自己的实例在拷贝、赋值、移动或销毁时做什么。类通过一些特殊的成员函数来控制这些操作——拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。  
我们称这些操作为**拷贝控制操作**。

## 1 拷贝、赋值与销毁

>在定义任何类时，拷贝控制操作都是必要部分。如果我们不显式定义他们，编译器会为我们定义，但该版本的行为可能并非对象或我们的预期。

### 1.1 拷贝构造函数

如果一个构造函数的第一个参数是其自身类类型的引用，且任何额外参数都有默认值，那这个就是拷贝构造函数。

>你可以想几个问题：为什么拷贝构造函数的第一个参数必须是引用类型？在c++基础部分笔记里，类的章节那部分还提到了，单参数构造函数可能会被用于隐式类型转换，那么拷贝构造函数呢？稍后进行解释。

```cpp
class Foo {
public:
    Foo();
    Foo(const Foo&); //拷贝构造函数
};
```

#### 合成拷贝构造函数

与普通构造一样，如果我们声明了拷贝构造函数，编译器就不会合成默认的版本（这时如果你没定义就会出现链接错误）。  
一般情况，合成的版本，会将其参数的成员逐个拷贝到正在创建的对象中，对于类类型的成员，则调用其拷贝构造函数。  
但是！**对于某些类，合成拷贝构造函数会阻止拷贝该类的对象**。比如在含有不可拷贝成员的类中，合成的版本会自动声明为 **deleted** 即不可用。

```cpp
struct A{
    A(const A&) = delete; //该类的对象不可拷贝；
}；
struct B{
    A a;
};

B b1;
B b2(b1); //失败！B中含有不可拷贝成员
```

#### 拷贝初始化 与 直接初始化

在上面的代码中，使用了b1来直接初始化b2。直接初始化是要求编译器使用普通的函数匹配，选择与我们提供的函数最匹配的构造函数（选择重载函数的哪个版本）。

```cpp
string dots(10, '.'); //直接初始化，调用了string的构造函数
string str(dots);  //直接初始化，调用了string的拷贝构造函数
```

拷贝初始化通常使用 拷贝构造函数 或 移动构造函数，并且中间可能会有隐式的类型转换发生。下列情况会发生拷贝初始化：

+ Classname cls1 = cls2;

+ 将一个对象作为实参传递给一个非引用类型的形参。
+ 从一个返回类型为 非引用类型 的函数，返回一个对象。
+ 用花括号初始化数组元素，或一个聚合类中的成员。

**为什么拷贝构造函数自己的参数必须是引用类型？** 要知道，拷贝构造函数被用来初始化非引用类类型参数。如果其形参不是引用类型，我们调用拷贝构造时，需要拷贝它的实参，但要拷贝实参，又需要调用拷贝构造——死循环了。

#### 拷贝初始化的限制

现在来回答本小小节开头时提到的第二个问题。我们有时候会使用 **explicit** 关键字阻止构造函数隐式使用。对于使用explicit声明的构造函数或拷贝构造，它只能用于直接初始化。或者显式调用它:

```cpp
vector<int> v1(10); 
vector<int> v2 = 10; //错误，vector接受大小的构造函数是explicit的

vector<int> v3 = vector<int>(10); //可以显式调用
```

### 1.2 拷贝赋值运算符

#### 重载赋值运算符

首先你要知道，**重载运算符**实际上是一个函数，也有返回类型与参数列表，**其名字**由 **operator关键字** 后接要定义的运算符的符号组成。因此赋值运算符就是一个名为 `operator=` 的函数。  
如果一个运算符是一个成员函数，那么在它的定义内，其左侧对象被绑定到隐式的this指针上。

>某些运算符必须定义为成员函数。

```cpp
struct Book {
    std::string bkname;
    int ISBN;
    int nums;

    Book& operator=(const Book& bk){
        bkname = bk.bkname;
        ISBN = bk.ISBN;
        nums = bk.nums;
        return *this;
    }
}
```

类似拷贝构造，**合成拷贝赋值运算符**会阻止某些类的拷贝。如果不是这样，它会将其右侧对象的非静态成员 赋予 左侧对象的对应成员。

### 1.3 析构函数

析构函数由波浪号接类名组成。析构函数不接受参数，也不能被重载。它释放对象使用的资源，销毁对象的非static数据成员。

```cpp
struct Myclass{
    ~Myclass();
}
```

#### 析构函数做什么工作的？

在构造函数中，成员的初始化是在函数体之前，按照其在类中出现的顺序初始化。  
而对于析构函数，先执行函数体，后按成员出现的逆序销毁。  
析构函数没有类似构造函数初始化列表那样的东西，来控制成员如何销毁。析构的部分是隐式的。销毁类类型的成员需要使用成员自己的构造函数。

>析构函数的函数体内，负责销毁对象内动态分配的内存。其他成员是在这之后隐含的析构阶段被销毁。  
需要析构函数的类**通常**也需要拷贝和复制操作。

#### 合成析构函数

类似合成拷贝构造函数、合成拷贝赋值运算符，对于某些类，合成析构函数会被用来阻止该类型的对象被销毁。

### 1.4 定义默认拷贝 或 阻止拷贝

**大多数类应该定义默认构造函数、拷贝构造函数、拷贝赋值运算符**，无论是显式的还是隐式的，显示的可以由程序员通过 `=default` 生成，这样可以进行访问控制；隐式的由编译器在未定义时，自动合成。

**但是对某些类来说，拷贝操作没有意义**，这时我们可以使用 `=delete` 定义**删除的函数**，从而阻止拷贝。

#### private拷贝控制

在新标准发布之前，类通过将其 拷贝构造函数 和 拷贝赋值运算符 声明为 `private` 来阻止拷贝。对于这种情况，用户代码无法拷贝这种类型的对象，但友元与成员函数仍然可以，除非**声明但不定义**。

## 2 拷贝控制 和 资源管理  

>当一个类需要析构函数，意味着他需要管理堆内存，而这时，通常也需要为他考虑拷贝操作。这里涉及到对象的拷贝语义——浅拷贝或深拷贝，即类的行为像一个指针、还是一个值。

### 2.1 行为像值的类——深拷贝

类有值的行为，意味着每个该类对象都有真正属于自己的资源。（对于类管理的资源，每个对象都有一份自己的拷贝）。  
例如，类 HasPtr 有动态分配的String容器（在堆内存），为了让该类的行为像值，HasPtr 需要：  
+ 拷贝构造函数，完成对 String 容器内容的拷贝，而不是拷贝指针。
+ 拷贝赋值运算符，用于释放对象当前的string，从右侧运算对象拷贝string。
+ 析构函数，释放string。

```cpp
class HasPtr{
public:
    //构造函数
    HasPtr(const std::string& s = std::string())：
        ps(new std:string(s)), i(0) { }
    //拷贝构造
    HasPtr(const HasPtr& p):
        ps(new std::string(*p.ps)), i(0) { }
    //拷贝赋值（定义在下面）
    HasPtr& operator=(const HasPtr& other);
    //析构
    ~HasPtr() { delete ps; }
private:
    std::string *ps;
    int i;
}
```
#### 类似值 拷贝赋值运算符

赋值运算符通常组合了析构与构造的操作，并以正确的顺序执行（确保自赋值正确）
```cpp
HasPtr& HasPtr::operator=(const HasPtr& other){
    auto newp = new std::string(*other.ps);
    delete ps;
    ps = newp;
    i = other.i;
    return *this;
}
```
上面的代码接续定义了 HasPtr 类的拷贝赋值运算符，先构造新的string，确保自赋值时能正常运行。

>拷贝赋值运算符的返回值，通常是当前类类型的引用（即左值引用 Classname&）。这符合c++支持链式赋值的语法特性。如果返回的是类类型的值（右值 Classname），这是一个临时对象，会触发额外的拷贝构造。

### 2.2 行为像指针的类——浅拷贝

对于行为像指针的类，他们的拷贝构造函数只是拷贝指针。会存在多个对象共享一段数据内存的情况。这时有个问题，我们需要在最后一个该对象销毁时，才释放这段内存。
一种方法是使用 shared_ptr ，另一种方法是自定义引用计数器。  
该引用计数器不能是类的成员，而应该是指针成员，指向位于堆内存中的计数器。

```cpp
class HasPtrB{
public:
    //构造函数，创建新的独立数据
    HasPtrB(const std::string& s = std::string()):
        ps(new std::string(s)), i(0), usecount(new std::size_t(1)) { }
    //拷贝构造，浅拷贝，拷贝指针，并增加引用计数
    HasPtrB(const HasPtrB& p):
        ps(p.ps), i(p.i), usecount(p.usecount) { ++*usecount; }
    //拷贝赋值，定义见类外
    HasPtrB& operator=(const HasPtrB&);
    //析构，定义见类外
    ~HasPtrB();

private:
    std::string *ps;
    int i;
    std::size_t usecount;
}

HasPtrB& HasPtrB::operator=(const HasPtrB& other){
    ++*other.usecount; //递增右侧对象引用计数
    if(--*usecount==0){  //递减左侧对象引用计数
        delete ps;       //如果归零，释放内存
        delete usecount;
    }
    //浅拷贝，拷贝指针
    ps = other.ps;
    usecount = other.usecount;
    i = other.i;
    return *this;
}
```
## 3 对象移动

### 3.1 右值引用

右值通常是临时对象、将要销毁的对象，通过引用的方式，稍微延长其生命周期，直到该引用离开其作用域。下面是右值引用的表示：
```cpp
int i = 37;
int &&r = i * 31; //将乘法结果绑定到右值引用
int &&r0 = i; //错误的，不能将右值引用绑定到左值
int &l = i * 31; //错误的，i*31是右值 
```
#### 变量是左值

变量可以看作只有一个运算对象而没有运算符的表达式。变量表达式都是左值的，结果就是，我们没法将右值引用绑定到右值引用上。

```cpp
int &&rr1 = 41 * 37;
int &&rr2 = rr1; //错误，rr1是左值。
```

虽然不能将右值引用绑定到左值，但是，我们可以通过 `std::move()` ，显式地将一个左值转化为对应的右值引用。

```cpp
int &&rr3 = std::move(rr1); //its ok!
```

>调用std::move就意味着承诺：除了对rr1赋值或者销毁，我们将不再使用它。

### 3.2 移动构造函数和移动赋值

移动操作类似拷贝操作，但他们窃取资源而不是拷贝资源。

移动构造函数的第一个参数是，该类类型的一个右值引用。与拷贝构造函数一样，任何额外参数都必须有默认值。  
特别注意，除了完成资源移动，移动操作还必须确保，移后源对象处于一个状态——销毁他是无害的。特别是，**一旦资源完成移动，源对象必须不再指向被移动的资源。这些资源的所有权已经归属于其他对象。**

>


## 4 
