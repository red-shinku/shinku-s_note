# Part iii 类设计者的工具 --面向对象设计

>你可以对类做什么..？

## 1 基类和派生类

### 1.1 继承

派生类继承自基类。通过继承联系在一起的类构成层次关系。基类负责定义在层次关系中所有类共同拥有的成员，派生类则定义各自特有的成员。

派生类通过**类派生列表**指明他从哪个类继承而来。具体写法：

`class A { ... }`  
`class B { ... }`  
`//类C继承自A和B`  
`class C : public A,  public B { ... }`



c++支持**多继承**，即可以有多个基类，这相比Java的单继承多接口来说复杂许多。你需要注意到更多可能出现的问题，比如菱形继承关系——B、C继承了A，D继承了B、C。这导致D中有两份A，编译器会报错（继承实际上嵌入了基类）。为了解决这个问题，可以使用**虚继承**，稍后会详细说明。

### 1.2 定义基类

#### 虚函数

如果基类拥有某个成员函数，我们会希望他的派生类能够实现各自的具体内容。这时候这个函数在基类需要被声明为**虚函数**。我们使用 **virtual** 关键字。

`class A {`  
`public :`  
$~~~~$`virtual int getpower() { return power; }`  
`protected:`  
$~~~~$`int basic_power; `  
`}`

在这个例子中，A的派生类可以根据自身的基础属性来得到不同倍数的power，通过**重写方法**。或许你还注意到了**protected**关键字，在protected域中的成员可以被其派生类访问，而不能被外部访问。

>通常基类需要一个**虚析构函数**，否则通过基类指针delete派生类对象时，只会调用基类析构函数，造成内存泄漏。


### 1.3 定义派生类

在类派生列表，每个基类前可以有public、protected、private三种访问说明符中的一个。

>这里访问说明符的作用是，

---

#### 重写基类的虚函数

如果你不打算重写虚函数，你可以什么都不做。虚函数和其虚属性一起被继承，这时你可以从派生类调用基类版本，或者在派生类的派生类中重写。重写虚函数的方式是，重新声明该函数并定义。你知道**override**吗？c++11标准后，在函数定义的最后加上这个关键字，编译器就会知道你想要重写函数，这时如果你写了基类中不存在的函数，就会被抱怨（防止误输入）。

---

#### 派生类构造函数

>每个类控制他自己的成员初始化过程。这也与每个类负责定义各自的接口有关。

派生类需要使用基类的构造函数来初始化他的基类部分。

`class A { ... }`  
`class B : public A { `  
`public:`  
$~~~~$`B(int n): A(...), number(n) {  }`  
`private:`  
$~~~~$`int number`  
`}`

上面例子中显式使用了基类的构造函数。如果你不这么做的话，编译器会使用基类的默认构造函数，如果基类没有默认构造函数，就会报错。Java与这是一样的，Java使用super()来显式构造基类。而C++的多继承，则需要给出具体的构造函数名。

---

#### 继承与静态成员



### 1.4 派生类与基类间的 类型转换

一个派生类对象包含多个组成部分——一个含有派生类自己定义的非静态成员的的子对象，一个或多个基类的子对象（继承自基类的部分与派生类自定义的部分不一定是连续存储的）。因为派生类对象中有基类对应的组成部分，所以我们可以将派生类对象当成基类对象使用，将基类的指针或应用绑到派生类对象中的基类部分上。该过程是隐式的。

>这也是Java中向上转型的概念。向上转型后，只能访问基类的内容，但这是**多态**的一个关键技术。一个例子是，接受基类指针的函数，这使得该函数能够处理多个从该基类继承的类，而不需要为这些相似的类写重复的代码。向上转型总是安全的，与之相反的向下转型则需要十分小心。










