# Part iii 类设计者的工具 --面向对象设计

>你可以对类做什么..？

## 1 基类和派生类

### 1.1 继承

派生类继承自基类。通过继承联系在一起的类构成层次关系。基类负责定义在层次关系中所有类共同拥有的成员，派生类则定义各自特有的成员。

派生类通过**类派生列表**指明他从哪个类继承而来。具体写法：

`class A { ... };`  
`class B { ... };`  
`//类C继承自A和B`  
`class C : public A,  public B { ... };`



c++支持**多继承**，即可以有多个基类，这相比Java的单继承多接口来说复杂许多。你需要注意到更多可能出现的问题，比如菱形继承关系——B、C继承了A，D继承了B、C。这导致D中有两份A，编译器会报错（继承实际上嵌入了基类）。为了解决这个问题，可以使用**虚继承**，稍后会详细说明。

### 1.2 定义基类

#### 虚函数

如果基类拥有某个成员函数，我们会希望他的派生类能够实现各自的具体内容。这时候这个函数在基类需要被声明为**虚函数**。我们使用 **virtual** 关键字。

`class A {`  
`public :`  
$~~~~$`virtual int getpower() { return power; }`  
`protected:`  
$~~~~$`int basic_power; `  
`};`

在这个例子中，A的派生类可以根据自身的基础属性来得到不同倍数的power，通过**重写方法**。或许你还注意到了**protected**关键字，在protected域中的成员可以被其派生类访问，而不能被外部访问。

>通常基类需要一个**虚析构函数**，否则通过基类指针delete派生类对象时，只会调用基类析构函数，造成内存泄漏。


### 1.3 定义派生类

在类派生列表，每个基类前可以有public、protected、private三种访问说明符中的一个。

>这里访问说明符的作用是，

---

#### 重写基类的虚函数

如果你不打算重写虚函数，你可以什么都不做。虚函数和其虚属性一起被继承，这时你可以从派生类调用基类版本，或者在派生类的派生类中重写。重写虚函数的方式是，重新声明该函数并定义。你知道**override**吗？c++11标准后，在函数定义的最后加上这个关键字，编译器就会知道你想要重写函数，这时如果你写了基类中不存在的函数，就会被抱怨（防止误输入）。

---

#### 派生类构造函数

>每个类控制他自己的成员初始化过程。这也与每个类负责定义各自的接口有关。

派生类需要使用基类的构造函数来初始化他的基类部分。

`class A { ... };`  
`class B : public A { `  
`public:`  
$~~~~$`B(int n): A(...), number(n) {  }`  
`private:`  
$~~~~$`int number`  
`};`

上面例子中显式使用了基类的构造函数。如果你不这么做的话，编译器会使用基类的默认构造函数，如果基类没有默认构造函数，就会报错。Java与这是一样的，Java使用super()来显式构造基类。而C++的多继承，则需要给出具体的构造函数名。

---

#### 继承与静态成员

如果类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。你还可以通过类直接访问静态成员，而不必须通过对象。

`class A {  `  
`static num;`  
`};`

`A::num = 10;`



### 1.4 派生类与基类间的 类型转换

---
 
#### 派生类对象指针/引用 转向 基类对象指针/引用

一个派生类对象包含多个组成部分——一个含有派生类自己定义的非静态成员的的子对象，一个或多个基类的子对象（继承自基类的部分与派生类自定义的部分不一定是连续存储的）。因为派生类对象中有基类对应的组成部分，所以我们可以将派生类对象当成基类对象使用，将基类的指针或引用绑到派生类对象中的基类部分上。该过程是隐式的。

>这也是Java中向上转型的概念。向上转型后，只能访问基类的内容，但这是**多态**的一个关键技术。一个例子是，接受基类指针的函数，这使得该函数能够处理多个从该基类继承的类，而不需要为这些相似的类写重复的代码。向上转型总是安全的，与之相反的向下转型则需要十分小心。

---

#### 基类对象指针/引用 转向 派生类对象指针/引用

该转向的成功前提是该对象本来就是目标派生类的对象。这种转向不安全，必须检查。  
可以使用 **static_cast** 作编译期检查 或 **dynamic_cast** 作运行时检查。

`Base* pbase = new Derived; //Derived类继承Base类`  
`Derived* pder = static_cast<Derived*>(pbase); `

对于运行时检查，指针失败会返回null，引用失败会抛出std::bad_cast。

>不存在从基类向派生类的隐式转换。在对象之间也不存在类型转换。

---

#### 静态类型与动态类型

>指针或引用的静态类型与动态类型不同，正是c++支持多态性的根本所在。

来看下面这个例子,Derived 继承了 Base:

`struct Base { virtual void f(); };`  
`struct Derived : public Base { `  
$~~~~$`void f() override {  };`  
$~~~~$`void g();`  
`};`

`Base *pbase = new Derived();`

其中pbase的静态类型是Base*，在**编译期确定**；动态类型是Derived*，**运行时决定**。  
在编译期确定的静态类型决定了变量能使用哪些成员和函数。  
但是当类含有虚函数，并通过基类指针/引用调用虚函数时，会根据其动态类型确定调用哪个实现。  
在这个例子中，`pbase->f()`是合法的，它调用了Derived的版本。`pbase->g()`是非法的。

>如果表达式既不是指针也不是引用，则他的静态类型与动态类型一致。我们无论如何都不能改变该变量对应的对象的类型。

---



### 1.4 虚函数~再开

---

#### final 和 override 说明符

**final** 和 **override** 说明符都被加在函数声明的最后。使用final，意味着该函数为最终版本，不可再被之后的派生类重写。override用于检查，如果使用了override而没有重写基类中的函数，编译器会报错。

---

#### 虚函数与默认实参

>默认实参不会参与虚函数的多态。

如果某次函数调用使用了**默认实参**，该实参的值由本次调用的静态类型决定。

`struct Base {`  
$~~~~$`virtual void f(int x = 1) { std::cout << x; }`  
`};`  
`struct Derived : Base {`  
$~~~~$`void f(int x = 2) override { std::cout << x; }`  
`};`

`Derived p;`  
`Based *pb = &d;`  

`d.f(); //output 2`  
`pb->f(); //output 1`

`pb->f()` 调用的虽然是Derived版本，但默认实参x的值是根据其静态类型在编译时确定的。

>fImpl()?

---

#### 回避虚函数的机制

某些情况下，我们希望强迫执行虚函数的某个版本。使用**作用域运算符**可以做到这一点。

`Derived pd;`  
`pd->Base::f();`

>通常情况下，只有成员函数（或友元）中的代码才需要使用作用于运算符来回避虚函数的机制。

---

### 1.5 抽象基类

---

#### 纯虚函数

将函数定义为纯虚，告诉用户当前这个函数是没有实际意义的。在函数体的位置写 = 0 可以将一个虚函数说明为 **纯虚函数**。

`virtual void setmood() = 0;`

含有纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的派生类可以覆盖该接口。

>我们不能创建抽象类的对象。

---


## 2 访问控制与继承

### 2.1 公有、私有和受保护继承

还记得派生类继承列表中，每个基类前的访问说明符号吗？该**派生访问说明符**说明了从基类继承而来的成员在派生类中的最高访问权限。

>struct默认public继承，class默认private继承。

`class A {`  
`public: int a;`  
`protected: int b;`  
`private: int c;`  
`};`  
`class Pub : public A {  `  
`//a 在Pub中仍是public`  
`//b 在Pub中仍是protected`  
`//c 在Pub中仍是private`  
`};`  
`class Prot : protected A {`  
`//a 在Prot中变为 protected`  
`};`  
`class Priv : private A {`  
`//a 在Priv中变为private`  
`//b 在priv中变为private`  
`};`

你可以看到，使用派生访问说明符，实际上不会对类内的成员访问造成影响，但对于类的实例（对象）来说，protected 和 private是不可访问的。

`Prot test;`  
`test.a //错误！a对对象不可见。`

>public继承是最常用的继承方式，语义上是'is-a'; protected继承意味着仅限派生类内部可见，对象无法直接访问，常用于不希望外界直接拿基类接口。； private继承表示基类的接口对外部完全隐藏，常见于**实现复用**

### 2.2 派生类向基类转换的可访问性

**派生访问符**可以影响**向上转型**的可行范围（或者你可以提供更好更准确的描述），换个说法就是在不同层面向上转型的可访问性————派生类内部、派生类的派生类、外部代码。

*      对于public继承，向上转型是公开可访问的。外部代码、派生类的派生类、派生类内部，都能进行转换。  
*      对于protected继承，外部代码无法进行向上转型。派生类的派生类和派生类内部可以。  
*      对于privated继承，只有派生类自己内部（或者友元）才可进行向上转型。

`class B {  };`  
`class D : protected B {`  
$~~~~$`void foo() { B *p = this; } //在派生类自己内部可以转`  
`};`  
`class SubD : public D {`  
$~~~~$`void ok() { B *p = this; } //在子类内部也可以转`  
`};`  
  
`void outf(B* p) {  };`  

`int main() {  `  
$~~~~$`D d;`  
$~~~~$`outf(&d); //错误！！在外部不可转`  
`}`

上面代码若是改为D私有继承B，则在SubD的内部就不允许`B *p = this;`了（函数名也从ok()改为buok()吧！）。

>关于代码复用。对于public继承，是复用+"is a"的语义关系，用于抽象层次设计（哈基米是一种动物）。而protected继承只给自己和其后代类复用基类的实现，此派生类不希望外部将他随便当作基类看。对于private继承，这是纯粹的实现复用——只是借用了基类的功能，并没有"is a"的关系，在设计层面，private继承更接近**组合**，虽然语法上是继承。

>在Java中，组合即在一个类中使用其他类的对象。

### 2.3 友元与继承

就像友元关系不能传递一样，友元关系也不能继承。派生类的友元不能随意访问基类的成员，基类的友元不能随意访问派生类的成员。

>友元关系只对作出友元声明的类有效。记住！每个控制各自成员的访问权限。

### 2.4 改变个别成员的可访问性

有时我们需要改变派生类继承的某个名字（成员名）的访问级别。通过使用**using**声明达到这一目的。

`class B {`  
`public:`  
$~~~~$`std::size_t size() const { return n; }`  
`protected:`  
$~~~~$`std::size_t n;`  
`};`  
`class D : private B {`  
`public:`  
$~~~~$`using B::size;`  
`protected:`  
$~~~~$`using B::n;`  
`};`

本来D使用了私有继承，所以size和n是其私有成员，外部和子类都不可访问。但是using改变了他们的可访问性，D的对象将可以使用size，但仍不能使用n；而D的子类将可以使用n。

>using声明语句中名字的访问权限由该语句所在区域的访问说明符决定。效果相当于声明的名字免除了**派生访问说明符**的影响，其访问权限由区域**访问说明符**决定


## 3 继承中的类作用域

每个类定义自己的作用域，我们在这个作用域内定义类的成员。当存在继承关系时，**派生类的作用与嵌套在基类的作用域之内**。当一个名字在派生类作用域内无法解析，编译器将继续在外层的基类作用域中寻找该名字的定义。

---

### 3.1 在编译时进行名字查找

为什么我们不能使用基类对象、指针或引用访问派生类的成员？这是因为，其**静态类型**决定了该对象的哪些成员时可见的。例如我有一个D类继承了B类，现在试图用B的指针访问D类的独有成员——在B类中找不到该名字，编译器会尝试向外围作用域查找，但显然B类在这个继承体系中是最外围的作用域。

>这里再次说明，对于虚函数而言，静态类型里声明了其接口（合法性检查），而调用时根据其动态类型，在虚函数表里找到对应的实现并调用。

---

### 3.2 名字冲突与继承

派生类可以重用定义在基类中的名字，此时外层作用域（基类）的名字被**隐藏**。

`struct Base { int mem; };`  
`struct Derived : Base { int mem; //隐藏了基类中的mem };`

我们通过**作用域运算符来使用被隐藏的成员**。

`struct Derived : Base { int get_base_mem() { return Base::mem; } };`

作用域运算符指示编译器从Base类的作用域开始查找mem。

>除了重写虚函数之外，派生类最好不要重用定义在基类中的名字。

#### 对于重载函数的重用

>名字查找先于类型检查，类型即函数签名，变量类型、成员函数的返回值和参数等。

如果派生类（内层作用域）的某个成员函数与基类（外层作用域）的某个成员函数同名，即使函数签名不一致，派生类也不会重载基类中的函数，而是会在其作用域内隐藏该基类成员。  
如果派生类希望基类中所有版本的重载函数对他都是可见的，那他就不能重用该函数名，或者重用所有的版本。

---

## 4 构造函数与拷贝控制

### 4.1 虚析构函数







# buttom

