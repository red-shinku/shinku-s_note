# Part iii 类设计者的工具 --面向对象设计

>你可以对类做什么..？

## 1 基类和派生类

### 1.1 继承

派生类继承自基类。通过继承联系在一起的类构成层次关系。基类负责定义在层次关系中所有类共同拥有的成员，派生类则定义各自特有的成员。

派生类通过**类派生列表**指明他从哪个类继承而来。具体写法：

`class A { ... }`  
`class B { ... }`  
`//类C继承自A和B`  
`class C : public A,  public B { ... }`



c++支持**多继承**，即可以有多个基类，这相比Java的单继承多接口来说复杂许多。你需要注意到更多可能出现的问题，比如菱形继承关系——B、C继承了A，D继承了B、C。这导致D中有两份A，编译器会报错（继承实际上嵌入了基类）。为了解决这个问题，可以使用**虚继承**，稍后会详细说明。

### 1.2 定义基类

#### 虚函数

如果基类拥有某个成员函数，我们会希望他的派生类能够实现各自的具体内容。这时候这个函数在基类需要被声明为**虚函数**。我们使用 **virtual** 关键字。

`class A {`  
`public :`  
$~~~~$`virtual int getpower() { return power; }`  
`protected:`  
$~~~~$`int basic_power; `  
`}`

在这个例子中，A的派生类可以根据自身的基础属性来得到不同倍数的power，通过**重写方法**。或许你还注意到了**protected**关键字，在protected域中的成员可以被其派生类访问，而不能被外部访问。

>通常基类需要一个**虚析构函数**，否则通过基类指针delete派生类对象时，只会调用基类析构函数，造成内存泄漏。


### 1.3 定义派生类

在类派生列表，每个基类前可以有public、protected、private三种访问说明符中的一个。

>这里访问说明符的作用是，

---

#### 重写基类的虚函数

如果你不打算重写虚函数，你可以什么都不做。虚函数和其虚属性一起被继承，这时你可以从派生类调用基类版本，或者在派生类的派生类中重写。重写虚函数的方式是，重新声明该函数并定义。你知道**override**吗？c++11标准后，在函数定义的最后加上这个关键字，编译器就会知道你想要重写函数，这时如果你写了基类中不存在的函数，就会被抱怨（防止误输入）。

---

#### 派生类构造函数

>每个类控制他自己的成员初始化过程。这也与每个类负责定义各自的接口有关。

派生类需要使用基类的构造函数来初始化他的基类部分。

`class A { ... }`  
`class B : public A { `  
`public:`  
$~~~~$`B(int n): A(...), number(n) {  }`  
`private:`  
$~~~~$`int number`  
`}`

上面例子中显式使用了基类的构造函数。如果你不这么做的话，编译器会使用基类的默认构造函数，如果基类没有默认构造函数，就会报错。Java与这是一样的，Java使用super()来显式构造基类。而C++的多继承，则需要给出具体的构造函数名。

---

#### 继承与静态成员

如果类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。你还可以通过类直接访问静态成员，而不必须通过对象。

`class A {  `  
`static num;`  
`}`  

`A::num = 10;`



### 1.4 派生类与基类间的 类型转换

---
 
#### 派生类对象指针/引用 转向 基类对象指针/引用

一个派生类对象包含多个组成部分——一个含有派生类自己定义的非静态成员的的子对象，一个或多个基类的子对象（继承自基类的部分与派生类自定义的部分不一定是连续存储的）。因为派生类对象中有基类对应的组成部分，所以我们可以将派生类对象当成基类对象使用，将基类的指针或引用绑到派生类对象中的基类部分上。该过程是隐式的。

>这也是Java中向上转型的概念。向上转型后，只能访问基类的内容，但这是**多态**的一个关键技术。一个例子是，接受基类指针的函数，这使得该函数能够处理多个从该基类继承的类，而不需要为这些相似的类写重复的代码。向上转型总是安全的，与之相反的向下转型则需要十分小心。

---

#### 基类对象指针/引用 转向 派生类对象指针/引用

该转向的成功前提是该对象本来就是目标派生类的对象。这种转向不安全，必须检查。  
可以使用 **static_cast** 作编译期检查 或 **dynamic_cast** 作运行时检查。

`Base* pbase = new Derived; //Derived类继承Base类`  
`Derived* pder = static_cast<Derived*>(pbase); `

对于运行时检查，指针失败会返回null，引用失败会抛出std::bad_cast。

>不存在从基类向派生类的隐式转换。在对象之间也不存在类型转换。

---

#### 静态类型与动态类型

>指针或引用的静态类型与动态类型不同，正是c++支持多态性的根本所在。

来看下面这个例子,Derived 继承了 Base:

`struct Base { virtual void f(); }`  
`struct Derived : public Base { `  
$~~~~$`void f() override {  };`  
$~~~~$`void g();`  
`}`

`Base *pbase = new Derived();`

其中pbase的静态类型是Base*，在**编译期确定**；动态类型是Derived*，**运行时决定**。  
在编译期确定的静态类型决定了变量能使用哪些成员和函数。  
但是当类含有虚函数，并通过基类指针/引用调用虚函数时，会根据其动态类型确定调用哪个实现。  
在这个例子中，`pbase->f()`是合法的，它调用了Derived的版本。`pbase->g()`是非法的。

>如果表达式既不是指针也不是引用，则他的静态类型与动态类型一致。我们无论如何都不能改变该变量对应的对象的类型。

---



### 1.3 虚函数~再开

---

#### final 和 override 说明符

**final** 和 **override** 说明符都被加在函数声明的最后。使用final，意味着该函数为最终版本，不可再被之后的派生类重写。override用于检查，如果使用了override而没有重写基类中的函数，编译器会报错。

---

#### 虚函数与默认实参

>默认实参不会参与虚函数的多态。

如果某次函数调用使用了**默认实参**，该实参的值由本次调用的静态类型决定。

`struct Base {`  
$~~~~$`virtual void f(int x = 1) { std::cout << x; }`  
`}`  
`struct Derived : Base {`  
$~~~~$`void f(int x = 2) override { std::cout << x; }`  
`}`

`Derived p;`  
`Based *pb = &d;`  

`d.f(); //output 2`  
`pb->f(); //output 1`

`pb->f()` 调用的虽然是Derived版本，但默认实参x的值是根据其静态类型在编译时确定的。

>fImpl()?

---

#### 回避虚函数的机制

某些情况下，我们希望强迫执行虚函数的某个版本。使用**作用域运算符**可以做到这一点。

`Derived pd;`  
`pd->Base::f();`

>通常情况下，只有成员函数（或友元）中的代码才需要使用作用于运算符来回避虚函数的机制。

---

### 1.4 抽象基类

---

#### 纯虚函数

将函数定义为纯虚，告诉用户当前这个函数是没有实际意义的。在函数体的位置写 = 0 可以将一个虚函数说明为 **纯虚函数**。

`virtual void setmood() = 0;`

含有纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的派生类可以覆盖该接口。

>我们不能创建抽象类的对象。

---


## 2 访问控制与继承






# buttom

